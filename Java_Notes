Access modifier:
If we do not specify any access modifier, it becomes “package-private”.
Package-private means the variable or method or class is accessible to its own class, and also to any other class in the same package.
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
In the Java programming language, every application must contain a main method whose signature is:
public static void main(String[] args)
The main method accepts a single argument: an array of elements of type String.
This array is the mechanism through which the runtime system passes information to your application. For example:
java MyApp arg1 arg2
Each string in the array is called a command-line argument. Command-line arguments let users affect the operation of the application
without recompiling it.
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
集合接口
1.Collection
Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口
(如List和set)。
Collection接口存储一组不唯一，无序的对象。
2.List
List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，
第一个元素的索引为0，而且允许有相同的元素。
List接口存储一组不唯一，有序（插入顺序）的对象。
3.Set
Set具有与Collection完全一样的接口，只是行为上不同，Set不保存重复的元素。
Set接口存储一组唯一，无序的对象。
4.SortedSet
继承于Set保存有序的集合。
5.Map
Map接口存储一组键值对象，提供key（键）到value（值）的映射。
6.Map.Entry
描述在一个Map中的一个元素（键/值）对。是一个Map的内部类。
7.SortedMap
继承于Map，使Key保持在升序排列。
8.Enumeration
这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.Iterator;

ArrayList<SomeObject> someObjects;
SomeObject[] anArray;

//iterator:
    Iterator<SomeObject> it = someObjects.iterator();
    while(it.hasNext())
    {
        SomeObject oneObject = it.next();
        if(oneObject != null)
        {...}
    }

//for-each loop:
    for(SomeObject oneObject : anArray)
    {
        if(oneObject != null)
        {...}
    }
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

HashMap<String, String> hash_map;
hash_map = new HashMap<String, String>();
if (hash_map != null){
    hash_map.put("Key", "Value");
}
hash_map.get("Key");

Set<String> stringKeys = hash_map.keySet();
Iterator<String> it = stringKeys.iterator();

while(it.hasNext()){
    String key = it.next();
    String value = hash_map.get(key);
}

Set<Map.Entry<String, String>> set = hash_map.entrySet();
for(Map.Entry<String, String> sl : set){
    System.out.println("The key is " + sl.getKey() + " and the value is " + sl.getValue() + ".");
}

properties of a HashMap:
- no duplicate keys
- key-value pairs
- aka dictionary
- key maps to a value
- RPGS methods, among other methods
- in java.util 
- no "order"
- no primitive types allowed for keys or values
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
properties of a Set:
- no duplicate values
- no order
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
Class Object is the root of the class hierarchy. Every class has Object as a superclass.
1.boolean equals(Object obj) - Indicates whether some other object is "equal to" this one.
2.int     hashCode()         - Returns a hash code value for the object.
3.String  toString()         - Returns a string representation of the object.

public class SomeClass {
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (this.getClass() != obj.getClass()) {
            return false;
        }
        SomeClass other = (SomeClass) obj;
        // Some code here...
        // if(){}
        // else{}
    }
}
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
Parent p = new Parent();
Child c = new Child();

Parent p2 = new Child(); // Substitution
Child c2 = new Parent(); // Problem; needs more code to make it work
if(p3.getClass().getName().equals("Child")){ // This Parent is actually a Child
    Child c3 = (Child)p3; // Casting makes it work
}
if(p4 instanceof Child){ // This Parent is a Child or other children
    Child c4 = (Child)p4;
}

public class Car extends Vehicle implements Comparable<Car> {
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
To get a (pseudo-) random integer between, say, 60 and 75, we can do this:
import java.util.Random;
Random r = new Random();
r.nextInt(16); //0 to 15 inclusive
r.nextInt(16) + 60; //shifted up by 60, 0-15 becomes 60-75
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
import java.util.Scanner;

int getUserInputInt() {
    Scanner keyboardScanner;
    keyboardScanner = new Scanner(System.in);
    int userInt;
    String userString;
    System.out.print("Input the number:");

    if(keyboardScanner.hasNextInt()) // integer
    {
        userInt = keyboardScanner.nextInt();
        System.out.println("You input is " + userInt);
        return userInt;
    }
    else // not an integer
    {
        userString = keyboardScanner.next();
        System.err.println(userString + " is an error");
        return -1;
    }
}
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
public void pressEnterToContinue() {
    try {
        System.in.read();
    }
    catch(Exception e)
    {}
}
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
import java.util.concurrent.TimeUnit;

public void waitForSeconds(int numberOfSeconds) {
    try {
        TimeUnit.SECONDS.sleep(numberOfSeconds);
    }
    catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
Before Java 11:
boolean blank = string.trim().isEmpty();

After Java 11:
boolean blank = string.isBlank();
