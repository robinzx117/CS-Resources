Data -> Process -> Information
3V: volume, velocity, variety aspects.

Spatial Data:
    -Very tied to the physical space.
    -Multi-dimensional.
    -Complex geometrical shapes.
    -New query API.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Database:
    -contains many tables. A very large, integrated collection of data. Models real-world enterprise(Entities and Relationships).
    -is stored as a collection of files. Each file is a sequence of records. A record is a sequence of fields.
     one file   <---> one table
     one record <---> one tuple

Database Management System:
    -store
    -retrieve
    -manage

Data Model:
    -collection of concepts for describing data.
    -Relational model of data: Most widely used model. Relation is shown through the table with rows and columns.

Schema:
    -description of a particular collection of data, using given data model. Specifies name of relation, plus name and type of each column.

Relation(or table):
    -contains tuples and attributes. All rows are distinct.
    -#Rows = cardinality, #Fields = degree/arity.

Row(or tuple):
    -a set of fields that generally represents an "object" like a person or a music track.

Column(also attribute or field):
    -one of possibly many elements of data corresponding to the object represented by the row.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Database Design:
    -Phase 1: Requirement Analysis - What users(apps) expects from the database.
    -Phase 2: Conceptual Database Design - Build ER(Entity-Relationship) diagram.
    -Phase 3: Logical Database Design - Convert ER design into a relational database schema.

    -Conceptual design follows requirements analysis, yields a high-level description of data to be stored.
    -ER model popular for conceptual design. Constructs are expressive, close to the way people think about their applications.
    -Basic constructs: entities, relationships, and attributes (of entities and relationships).
    -Some additional constructs: weak entities, ISA hierarchies, and aggregation.
    -Several kinds of integrity constraints can be expressed in the ER model(Key, Participation, Overlap, Covering).

ER Model:
    -Entity:     real-world object distinguishable from other objects. An entity is described using a set of attributes.
    -Entity Set: a collection of similar entities. E.g., all employees.
                 1.All entities in an entity set have the same set of attributes.
                 2.Each entity set has a key.
                 3.Each attribute has a domain.
    -Relationship: association among 2 or more entities. A relationship is identified by its participating entities.
    -Relationship Set: collection of similar relationships.
    -Key constraint: 1-to-1, 1-to-Many, Many-to-Many.
    -Participation Constraint: total vs partial(default).
    -Weak entity: can be identifies uniquely only by considering the primary key of another(owner) entity.
                  1.Owner entity set and week entity set must participate in a one-to-many relationship set(one owner, many weak entities).
                  2.Weak entity set must have total participation in this identifying relationship set.
    -Class Hierarchies: as in C++, or other PLs, attributes are inherited. If we declare A ISA B, every A entity is also considered to be a B entity.
                        Overlap constraints: Can Joe be an Hourly_Emps as well as a Contract_Emps entity? (Allowed/Disallowed)
                        Covering constraints: Does every Employees entity also have to be an Hourly_Emps or a Contract_Emps entity? (Yes/No)
                        Reasons for using ISA: 1.To add descriptive attributes specific to a subclass. 2.To identify that participate in a relationship.
    -Aggregation: used when we have to model a relationship involving (entity sets and) a relationship set. Aggregation allows us to treat a relationship set as an entity
                  set for purposes of participation in (other) relationships.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Integrity Constraints: condition that must be true for any instance of the database.
                       -ICs are specified when schema is defined.
                       -ICs are checked when relations are modified.
                       -A legal instance of a relation is one that satisfied all specified ICs.
                       -DBMS should not allow illegal instances.
                       -If the DBMS check ICs, stored data is more faithful to real-world meaning.
                       -Avoids data entry errors, too!

Constructing the tables outwardly in.

Primary Key:
    -is used to ensure data in the specific column is unique. It is a column cannot have NULL values. It is either an existing table column or a column that is specifically
     generated by the database according to a defined sequence.

Foreign Key:
    -is a column or group of columns in a relational database table that provides a link between data in two tables. It is a column(or columns) that references a column
     (most often the primary key) of another table. If all foreign key constraints are enforced, referential integrity is achieved, i.e., no dangling references.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Page access cost is usually the dominant cost of database operations.

Alternative File Organizationsï¼š
    Heap Files:
     -Random order.
     -Suitable when typical access is a file scan retrieving all records.
     -Advantages:
      Efficient -for bulk loading data.
                -for relatively small relations as indexing overheads are avoided.
                -when queries that need to fetch large proportion of stored records.
     -Disadvantages:
      Not Efficient -for selective queries.
                    -for sorting, may be time-consuming.

    Sorted Files:
     -Best if records must be retrieved in some order, or only a range of records is needed.

    Indexes:
     -Data structures to organize records via trees or hashing.
     -Speeds up selections on the search key fields.
     -Any subset of the fields of a relation can be the search key for an index on the relation.
     -An index contains a collection of data entries, and supports efficient retrieval of all data entries k* with a given key value k.
     -A file can be clustered on at most one search key.
      Hash-Based Indexes:
       -Good for equality selections.
       -Hashing function h: h(r) = bucket in which (data entry for) record r belongs. h looks at the search key fields of r.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Transaction:
    -is the DBMS's abstract view of a user's program: a sequence of reads and writes. It is a collection of actions that make consistent transformations of system states
     while preserving system consistency.

ATOMICITY all or nothing:
    -A transaction might commit after completing all its actions, or it could abort after executing some actions.
    -Always executing all actions in one step, or not executing any actions at all.
    -DBMS logs all actions so that it can undo the actions of aborted transactions.

CONSISTENCY no violation of integrity constraints:
    -A transaction which executes alone against a consistent database leaves it in a consistent state.
    -Transactions do not violate database integrity constraints.
    -Transactions are correct programs.

ISOLATION concurrent changes invisible->serializable:
    -Serializability:    If several transactions are executed concurrently, the results must be the same as if they were executed serially in some order.
    -Incomplete results: An incomplete transaction cannot reveal its results to other transactions before its commitment.

DURABILITY committed updates persist:
    -Once a transaction commits, the system must guarantee that the results of its operations will never be lost, in spite of subsequent failures.
    -Database recovery.

Scheduling Transactions:
    -1.Serial Schedule:       Schedule that does not interleave the actions of different transactions.
    -2.Equivalent Schedule:   For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule.
    -3.Serializable Schedule: A schedule that is equivalent to some serial execution of the transactions.

Conflict Serializable Schedules:
    -Two schedules are conflict equivalent if: 1.Involve the same actions of the same transactions.
                                               2.Every pair of conflicting actions is ordered the same way.
Schedule S is conflict serializable if S is conflict equivalent to some serial schedule.

Strict Two-Phase Locking (Strict 2PL) Protocol:
-Each transaction must obtain a shared lock on object before reading, and an exclusive lock on object before writing.
-All locks held by a transaction are released when the transaction completes.
-Strict 2PL allows only serializable schedules.
-It simplifies transaction aborts.

Lock manager:
    -Lock and unlock requests are handled by the lock manager.
    -Locking and unlocking have to be atomic operations.
    -Lock upgrade: transaction that holds a shared lock can be upgraded to hold an exclusive lock.

Deadlock:
    -Cycle of transactions waiting for locks to be released by each other.
    -Two ways of dealing with deadlocks: 1.Deadlock Prevention 2.Deadlock Detection

Deadlock Detection:
    Create a waits-for graph:
        -Nodes are transactions.
        -There is an edge from Ti to Tj if Ti is waiting for Tj to release a lock.
        -Periodically check for cycles in the waits-for graph.

Fault->(causes)Error->(results in )Failure

Database Log:
    -Every action if a transaction must not only perform the action, but must also write a log record to an append-only file.
    -The following actions are recorded in the log:
        Ti writes an object: the old value and the new value. Log record must go to disk before the changed page.
        Ti commits/aborts: a lot of record indicating this action.
    -Log records are chained together by transactions id, so it's easy to undo a specific transaction.
    -All log related activities are handled transparently by the DBMS.

Logging:
    -The log contains information used by the recovery process to restore the consistency of a system. This information may include:
        1.transaction identifier
        2.type of operation(action)
        3.items accessed by the transaction to perform the action
        4.old value(state) of item(before image)
        5.new value(state) of item(after image)

Write-Ahead Log Protocol:
    -If a system crashes before a transaction is committed, then all the operations must be undone. Only need the before images(undo).
    -Once a transaction is committed, some of its actions might have to be redone. Need the after images(redo).
    -Before a stable database is updated, the undo portion of the log should be written to the stable log.
    -When a transaction commits, the redo portion of the log must be written to stable log prior to the updating of the stable database.
There are 3 phases in the ARIES(Algorithm for Recovery and Isolation Exploiting Semantics):
1.Analysis: Scan the log forward(from the most recent checkpoint) to identify all transactions that were active, and all dirty pages in the buffer pool at the time of the crash.
2.Redo
3.Undo

Concurrency control and recovery are among the most important functions provided by a DBMS.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Query Language:
Procedural/Imperative Language: Relational Algebra
    -Instructs the system to perform a sequence of operators to compute a result.
Non-Procedural/Declarative Language: Relational Calculus, SQL
    -Tells what data is to be retrieved but does not tell the system how to retrieve the data.

SQL(Structured Query Language):
    -is the language we use to issue commands to the database.
    -CRUD(create, read, update, delete)

SQL support all 4 options on deletes and updates:
    -Default is NO ACTION (delete/update is rejected).
    -CASCADE (also delete all tuples that refer to deleted tuple).
    -SET NULL/SET DEFAULT (sets foreign key value of referencing tuple).

SELECT [DISTINCT] target-list
FROM relation-list
WHERE qualification
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PostgreSQL command:
psql -U postgres (the password is the one set during the installation)
\c database_name; - Connect to a specific database.
\dt               - Lists all tables in a current database.
\q                - To quit the psql.
