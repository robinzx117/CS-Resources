32位处理器一次只能处理32位，也就是4个字节的数据；而64位处理器一次就能处理64位，即8个字节的数据。
如果将总长128位的指令分别按16位、32位、64位为单位进行编辑的话：32位的处理器需要4个指令，而64位处理器则只要两个指令。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In Java:
int is 32 bits (–2,147,483,648 to 2,147,483,647)
long is 64 bits (–9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ASCII（American Standard Code for Information Interchange，美国标准信息交换码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本延伸美国标准信息交换码则可以部分支持其
他西欧语言，并等同于国际标准ISO/IEC 646。
EASCII（Extended ASCII，延伸美国标准信息交换码）是将ASCII码由7位扩充为8位而成。EASCII的内码是由0到255共有256个字符组成。EASCII码比ASCII码扩充出来的符号包括表格符号、计算符号、希腊字母和特
殊的拉丁符号。
int[26]  for Letters 'a' - 'z' or 'A' - 'Z'
int[128] for ASCII
int[256] for Extended ASCII
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The Hamming weight of a string is the number of symbols that are different from the zero-symbol of the alphabet used.

位运算符作用在所有的位上，并且按位运算。假设A=60，B=13,它们的二进制格式表示将如下：
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A  = 1100 0011
&	如果相对应位都是1，则结果为1，否则为0.            （A&B） 得到12， 即0000 1100
|	如果相对应位都是0，则结果为0，否则为1.            （A|B） 得到61， 即0011 1101
^	如果相对应位值相同，则结果为0，否则为1.           （A^B） 得到49， 即0011 0001
~	按位取反运算符翻转操作数的每一位，即0变成1，1变成0.（~A）  得到-61，即1100 0011
== has higher precedence than &

If we take XOR(^) of zero and some bit, it will return that bit:
a⊕0=a
If we take XOR of two same bits, it will return 0:
a⊕a=0
a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b

(x^y) is addition without carry. (x&y) is the carry-out from each bit. (x&y)<<1 is the carry-in to each bit.
